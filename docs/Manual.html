<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Smoother Manual &mdash; smoother 0.0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Documentation for the Preprocessing script" href="Preprocess.html" />
    <link rel="prev" title="Smoother" href="Readme.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> smoother
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Readme.html">Smoother</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Smoother Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="#importing-data">Importing Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preprocessing-data-anna">Preprocessing Data (<em>Anna</em>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#create-index-anna">Create Index (<em>Anna</em>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-replicates-anna">Adding Replicates (<em>Anna</em>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-normalization-tracks-anna">Adding Normalization Tracks (<em>Anna</em>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-grid-seq-normalizations-todo-better-name-markus">Adding Grid-seq normalizations (&#64;todo better name) (<em>Markus</em>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#list-of-plots-and-what-they-show-anna">List of Plots and what they show (<em>Anna</em>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#list-of-buttons-and-their-functionality-both">List of Buttons and their functionality (<em>Both</em>)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#normalization-markus">Normalization (<em>Markus</em>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quick-config-buttons-anna">Quick Config Buttons (<em>Anna</em>)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-slurm-markus">Using Slurm (<em>Markus</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#installing-via-github-markus">Installing via GitHub (<em>Markus</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-a-webserver-markus">Setting up a Webserver (<em>Markus</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-datastructure-markus">The Datastructure (<em>Markus</em>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#algorithmic-description">Algorithmic Description</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#f1-constant-lookup-times">F1: Constant lookup times</a></li>
<li class="toctree-l4"><a class="reference internal" href="#f2-filtering-for-mapping-quality">F2: Filtering for mapping quality</a></li>
<li class="toctree-l4"><a class="reference internal" href="#f3-interactions-that-map-to-multiple-consecutive-loci">F3: Interactions that map to multiple consecutive loci</a></li>
<li class="toctree-l4"><a class="reference internal" href="#f4-optimizing-memory-requirements">F4: Optimizing memory requirements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#fileformat-specification">Fileformat specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-details">Implementation Details</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#libraries">Libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runtime-benchmarking">Runtime benchmarking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#verification-of-normalizations">Verification of Normalizations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#citing-smoother">Citing Smoother</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
<li class="toctree-l2"><a class="reference internal" href="#thanks-to">Thanks to…</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Preprocess.html">Documentation for the Preprocessing script</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">smoother</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Smoother Manual</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Manual.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="smoother-manual">
<h1>Smoother Manual<a class="headerlink" href="#smoother-manual" title="Permalink to this headline"></a></h1>
<p>Bulk of the manual</p>
<section id="table-of-contents">
<h2>Table of Contents<a class="headerlink" href="#table-of-contents" title="Permalink to this headline"></a></h2>
</section>
<section id="importing-data">
<h2>Importing Data<a class="headerlink" href="#importing-data" title="Permalink to this headline"></a></h2>
<section id="preprocessing-data-anna">
<h3>Preprocessing Data (<em>Anna</em>)<a class="headerlink" href="#preprocessing-data-anna" title="Permalink to this headline"></a></h3>
<p>generating the chromosome lengths file
annotation file
bed &amp; wig files
input formats
output all alignments
provide some sample files</p>
</section>
<section id="create-index-anna">
<h3>Create Index (<em>Anna</em>)<a class="headerlink" href="#create-index-anna" title="Permalink to this headline"></a></h3>
<p>creating an empty index
adding genome sizes
and annotation file
min bin size parameter</p>
</section>
<section id="adding-replicates-anna">
<h3>Adding Replicates (<em>Anna</em>)<a class="headerlink" href="#adding-replicates-anna" title="Permalink to this headline"></a></h3>
<p>adding hi-c or radicl-seq replicates</p>
</section>
<section id="adding-normalization-tracks-anna">
<h3>Adding Normalization Tracks (<em>Anna</em>)<a class="headerlink" href="#adding-normalization-tracks-anna" title="Permalink to this headline"></a></h3>
<p>adding read or wig normalization tracks</p>
</section>
<section id="adding-grid-seq-normalizations-todo-better-name-markus">
<h3>Adding Grid-seq normalizations (&#64;todo better name) (<em>Markus</em>)<a class="headerlink" href="#adding-grid-seq-normalizations-todo-better-name-markus" title="Permalink to this headline"></a></h3>
<p>creating relevant plots (infliction point)
setting parameters
adding as normalization track</p>
</section>
<section id="list-of-plots-and-what-they-show-anna">
<h3>List of Plots and what they show (<em>Anna</em>)<a class="headerlink" href="#list-of-plots-and-what-they-show-anna" title="Permalink to this headline"></a></h3>
<p>the heatmap the ratio &amp; coverage plots
mention hovers
also include status text &amp; command line output</p>
</section>
<section id="list-of-buttons-and-their-functionality-both">
<h3>List of Buttons and their functionality (<em>Both</em>)<a class="headerlink" href="#list-of-buttons-and-their-functionality-both" title="Permalink to this headline"></a></h3>
<p>top to bottom list of things
group by category
don’t forget the bokeh buttons</p>
<section id="normalization-markus">
<h4>Normalization (<em>Markus</em>)<a class="headerlink" href="#normalization-markus" title="Permalink to this headline"></a></h4>
<section id="normalize-by">
<h5>Normalize by<a class="headerlink" href="#normalize-by" title="Permalink to this headline"></a></h5>
<p>Smoother can normalize data in various ways. Some of them are suited for symmetric data (e.g. Hi-C), some for asymmetric data (e.g. RADICL-seq).
For some normalizations, views or different regions or with different bin sizes are not comparable.
Note that for these normalizations, even zooming or moving around may skew the displayed values.
It is recommended to use these normalizations merely as an exploratory tool but never to compare e.g. two screenshots of different regions.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Picture</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>For Symm.</p></th>
<th class="head"><p>For Asymm.</p></th>
<th class="head"><p>Always Comparable</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Largest Rendered Bin</p></td>
<td></td>
<td><p>Divide the number of interactions in each bin the number of interactions in the largest rendered bin. This keeps differences between bins nicely visible by always ensuring that the colorscale is used fully.</p></td>
<td><p>✔️</p></td>
<td><p>✔️</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Reads per Million</p></td>
<td></td>
<td><p>Divide the number of interactions in each bin by the number of million reads in the dataset.</p></td>
<td><p>✔️</p></td>
<td><p>✔️</p></td>
<td><p>✔️</p></td>
</tr>
<tr class="row-even"><td><p>Reads per Thousand</p></td>
<td></td>
<td><p>Divide the number of interactions in each bin by the number of thousand reads in the dataset.</p></td>
<td><p>✔️</p></td>
<td><p>✔️</p></td>
<td><p>✔️</p></td>
</tr>
<tr class="row-odd"><td><p>Column Sum</p></td>
<td></td>
<td><p>Divide the number of interactions in each bin by the number of interactions in the complete column that bin belongs to.</p></td>
<td></td>
<td><p>✔️</p></td>
<td><p>✔️</p></td>
</tr>
<tr class="row-even"><td><p>Row Sum</p></td>
<td></td>
<td><p>Divide the number of interactions in each bin by the number of interactions in the complete row that bin belongs to.</p></td>
<td></td>
<td><p>✔️</p></td>
<td><p>✔️</p></td>
</tr>
<tr class="row-odd"><td><p>Coverage of Normalization Reads (Absolute)</p></td>
<td></td>
<td><p>Divide the number of interactions in each bin by the coverage of the normalization datasets. With the ‘Normalization Rows’ and ‘Normalization Columns’ pickers, you can decide what datasets should be used for the columns and rows.</p></td>
<td><p>✔️</p></td>
<td><p>✔️</p></td>
<td><p>✔️</p></td>
</tr>
<tr class="row-even"><td><p>Coverage of Normalization Reads (Scaled)</p></td>
<td></td>
<td><p>Same as the absolute version, but makes sure the complete colorscale is used.</p></td>
<td><p>✔️</p></td>
<td><p>✔️</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Binominal Test</p></td>
<td></td>
<td><p>Use a binominal test to determine weather each bin is statistically significant, in it’s row. This strategy was created by Bonetti et al. for RADICL-seq RNA-DNA interaction data [3]. The acceptance p-value can be modified with a slider. <a href="#id1"><span class="problematic" id="id2">*</span></a>For views that do not show the entire genome, we use an approximation for the p-value adjustment that is performed after the binominal test.</p></td>
<td></td>
<td><p>✔️</p></td>
<td><p>✔️*</p></td>
</tr>
<tr class="row-even"><td><p>Iterative Correction</p></td>
<td></td>
<td><p>Use the iterative correction approach developed for Hi-C data by Imakaev et al. [4]. &#64;todo this is ICE correct?</p></td>
<td><p>✔️</p></td>
<td></td>
<td><p>✔️</p></td>
</tr>
</tbody>
</table>
<p>Since smoother is capable of normalizing data on the fly, you can zoom in to a region of interest and then dynamically change the normalization strategy.</p>
<p>Groups A and B are normalized individually and then combined according to the ‘Between Group’ setting (see Replicates section).
The ‘In Group’ operation (see Replicates section) is applied before the Normalization.</p>
</section>
<section id="color-scale-begin-color-scale-log-base">
<h5>Color Scale Begin &amp; Color Scale Log Base<a class="headerlink" href="#color-scale-begin-color-scale-log-base" title="Permalink to this headline"></a></h5>
<p>After normalization, the values in each bin are between zero and one.
Before displaying these values in the heatmap, we apply a logarithmic transformation.
Like with logarithmic scales, this keeps all values in the same order but this makes a difference between two small numbers appear bigger than the same difference between two bigger numbers.
You can fiddle with the strength of this effect using the ‘Color Scale Log Base’ slider.
In brief, higher values for the log base increase the difference between small numbers but make larger number look more similar.
Lower values do the opposite.
Setting log base to zero displays the numbers without any transformation.</p>
<p>Additionally, the ‘color scale begin’ slider can be used to cut off the bottom of the color scale, i.e. to only show bins with more than x interactions.
This option subtracts from the raw number of interactions; it is applied before normalization and application of the log scale.</p>
<p>In detail, the function we use is:</p>
<img src="../static/log_scale.png"/><p>, where <em>x</em> and <em>y</em> are the un-normalized and normalized interaction frequencies while <em>a</em> is the log base parameter.
With varying values for <em>a</em>, this function always satisfies <em>f(0)=0</em> and <em>f(1)=1</em>.
for <em>a=0</em> the function is undefined but approaches the 45-degree diagonal, so we hardcode <em>f(x)=x</em> for <em>a=0</em>.</p>
</section>
</section>
<section id="quick-config-buttons-anna">
<h4>Quick Config Buttons (<em>Anna</em>)<a class="headerlink" href="#quick-config-buttons-anna" title="Permalink to this headline"></a></h4>
<p>what do they change</p>
</section>
</section>
</section>
<section id="using-slurm-markus">
<h2>Using Slurm (<em>Markus</em>)<a class="headerlink" href="#using-slurm-markus" title="Permalink to this headline"></a></h2>
<p>Smoother is set up to be run on a server within the <span class="raw-html-md"><a href="https://slurm.schedmd.com/overview.html" title="Go to the Slurm Webpage">Slurm Workload Manager</a></span>.
For this, you need to log into the main node of the server, with ssh port forwarding.
The default port that needs to be forwarded is 5009; this requires the following login command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ssh</span> <span class="o">-</span><span class="n">L</span> <span class="mi">5009</span><span class="p">:</span><span class="n">localhost</span><span class="p">:</span><span class="mi">5009</span> <span class="o">-</span><span class="n">t</span> <span class="n">your_user_name</span><span class="nd">@your_server</span><span class="o">.</span><span class="n">com</span>
</pre></div>
</div>
<p>Then you can navigate into the smoother folder and call the srun.sh script.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">srun</span><span class="o">.</span><span class="n">sh</span>
</pre></div>
</div>
<p>This will then log into one of the slurm-client nodes (again using the port forwarding) and start smoother there.
The command will print an url on your terminal.
Follow this link with any webbrowser to open smoother on the server.</p>
</section>
<section id="installing-via-github-markus">
<h2>Installing via GitHub (<em>Markus</em>)<a class="headerlink" href="#installing-via-github-markus" title="Permalink to this headline"></a></h2>
<p>For installing smoother via github, run the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># clone repository</span>
<span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">MarkusRainerSchmidt</span><span class="o">/</span><span class="n">smoother</span>
<span class="n">cd</span> <span class="n">smoother</span>

<span class="c1"># create the required conda environment</span>
<span class="o">./</span><span class="n">conda_env</span><span class="o">/</span><span class="n">create_smoother_env</span><span class="o">.</span><span class="n">sh</span>

<span class="c1"># @todo run the install commands -&gt; see bioconda integration</span>
</pre></div>
</div>
</section>
<section id="setting-up-a-webserver-markus">
<h2>Setting up a Webserver (<em>Markus</em>)<a class="headerlink" href="#setting-up-a-webserver-markus" title="Permalink to this headline"></a></h2>
<p>smoother can be deployed as a webserver so this should be described</p>
</section>
<section id="the-datastructure-markus">
<h2>The Datastructure (<em>Markus</em>)<a class="headerlink" href="#the-datastructure-markus" title="Permalink to this headline"></a></h2>
<p>Smoother uses a datastructure called libSps implemented in C++ for querying the interactions as effectiveley as possible.
You can find the <span class="raw-html-md"><a href="https://github.com/MarkusRainerSchmidt/libSps" title="Go to the libSps GitHub">GitHub of libSps here</a></span>.</p>
<section id="algorithmic-description">
<h3>Algorithmic Description<a class="headerlink" href="#algorithmic-description" title="Permalink to this headline"></a></h3>
<p>libSps provides several features that make it possible to bin, normalize and visualize nucleic acid interaction data on-the-fly.
In brief, these are:</p>
<ul class="simple">
<li><p>F1: Looking up the number of interactions within any rectangle in constant time (i.e. the lookup time is independent of the total number of interactions and the number of interactions in the rectangle)</p></li>
<li><p>F2: During this lookup, interactions can be filtered for mapping quality (again this is done in constant time)</p></li>
<li><p>F3: libSps can distinguish between interactions that map to multiple consecutive loci and multiple distributed loci (we want to count the first but exclude the latter)</p></li>
<li><p>F4: The memory requirements for libSps are optimized</p></li>
</ul>
<section id="f1-constant-lookup-times">
<h4>F1: Constant lookup times<a class="headerlink" href="#f1-constant-lookup-times" title="Permalink to this headline"></a></h4>
<p>libSps uses a technique called prefix sums [1] for storing interaction counts.
With prefix sums, each cell in a matrix stores the number of interactions that can be found to its bottom-left.</p>
<img src="../static/algorithmics_desc/2d-prefix-sum.png" /><p><em>Example prefix sum matrix.</em> The left picture shows the positions of individual points. The middle picture shows the matrix entries after prefix sums have been computed for the y-dimension. The right picture shows the matrix entries after prefix sums have been computed for the x and y dimension.</p>
<p>Once the prefix sums have been computed, looking up the entry at a position x/y returns the number of points between 0/0 and x/y.
By looking up 4 entries and adding their values together, we can query and arbitrary rectangle.
This lookup is extremely fast, as it is independent of the total number of interactions and the number of interactions in the queried rectangle.</p>
<img src="../static/algorithmics_desc/2d-prefix-sum-query.png" /><p><em>Querying a prefix sum matrix.</em> Four lookups are needed, one lookup positioned at each corner of the queried rectangle. The top-left and bottom-right corner values are subtracted from the value at the top-right to exclude the area to the left and bottom of the queried rectangle (left), respectiveley. This subtracts the area to the bottom-left of the queried rectangle twice. To make up this difference the value of the bottom-left corner lookup is added to the previous result.</p>
<p>This approach enables us to count the number of interactions in any bin on-the-fly.
In turn, this makes it possible to have varying bin-sizes and normalizations.</p>
</section>
<section id="f2-filtering-for-mapping-quality">
<h4>F2: Filtering for mapping quality<a class="headerlink" href="#f2-filtering-for-mapping-quality" title="Permalink to this headline"></a></h4>
<p>Smoother has a slider to dynamically filter out reads with too low or high mapping qualities.
Mapping qualities are scores that express an aligners confidence that the read was mapped correctly.
For each interaction (i.e. read-pair with a mapping quality), we place the point at a height according to the mapping quality of the reads.
If both reads have different mapping qualities, we use the lower value.</p>
<p>Then we query cubes instead of rectangles, where the bottom and top of the cubes are defined by the mapping quality slider.</p>
<img src="../static/algorithmics_desc/mapq-filter.png" width="50%" /><p><em>Filtering mapping qualities using a 3rd dimension.</em></p>
</section>
<section id="f3-interactions-that-map-to-multiple-consecutive-loci">
<h4>F3: Interactions that map to multiple consecutive loci<a class="headerlink" href="#f3-interactions-that-map-to-multiple-consecutive-loci" title="Permalink to this headline"></a></h4>
<p>Genomes have many forms of repetition.
For example, In <em>Trypanosome brucei</em>, the organism we study, genes are often placed in arrays.
I.e. there are many immediateley consecutive copies of the same gene on the genome.
Interactions that map to one of these genes will most likely map to all copies of that gene.
Often, a bin will span over the entirety of such a gene array.
In this case, we want to count interactions that map to all genes in the array towars the bin, as, no matter which gene copy the interaction truly originates from, we know that it originates from within the bin.
In other cases, where an interaction maps to several positions in different bins, we cannot decide which bin to count the interaction towards and therefore filter out the interaction instead.</p>
<p>In the following, we show how we solve the above problem.</p>
<p>First, instead of storing the prefix sums for individual interaction points, we summarize all mapping positions of each interaction into one rectangle.
Here, the rectangle is placed so that it encompasses all mapping positions.</p>
<img src="../static/algorithmics_desc/multiple-loci-in-one-bin.png" width="50%" /><p><em>Interaction with multiple mapping positions turned into an rectangle.</em></p>
<p>We then compute prefix sum matrices seperately for all four corners of the rectangle.
In the following, we go down to Intervals (i.e. 1-dimensional rectangles) for a simpler example, but in principle everything works the same in the 2-dimensional or n-dimensional case.</p>
<p>To count the number of intervals between a given start and end position, we look up the number of intervals that end before the given end position and the number of intervals that start before the given start position.
Then we substract the latter from the former to receive our count.
Both lookups can be done in constant time using the two prefix sum matrices.</p>
<img src="../static/algorithmics_desc/counting-intervals.png" width="50%" /><p><em>Counting intervals instead of points using prefix sum matrices.</em></p>
<p>This strategy works fine as long as there is no interval that completely encloses our query region.</p>
<img src="../static/algorithmics_desc/too-large-intervals.png" width="50%" /><p><em>Too large intervals break our strategy.</em></p>
<p>However, we already developed a strategy for filtering out interactions based on a single numerical property: See F2 - Filtering for mapping quality.
We hence reuse this strategy, placing the rectangles at a position given bey their width and height in a 4th and 5th dimension.
Again, we can then use the bottom and top positions of our 5d-orthotope queries (5-dimensional “cubes”) to filter out all rectangles that are too wide or high.</p>
<img src="../static/algorithmics_desc/rectangle-width.png" width="50%" /><p><em>Adding two more dimensions to filter rectangle width and height.</em></p>
</section>
<section id="f4-optimizing-memory-requirements">
<h4>F4: Optimizing memory requirements<a class="headerlink" href="#f4-optimizing-memory-requirements" title="Permalink to this headline"></a></h4>
<p>The strategy, as described above, would not be feasible as the required matrices are simply too large to be stored or computed.
For example, we work with a genome assembly of <em>Trypanosome brucei</em> that contains 50,081,021 nucleotides.
Rather small considering e.g. the size of the human genome.
Even so, a genome x genome x mapping confidence matrix is of size 50,081,021^2 * 256 = 583,964 Terrabytes (even if each prefix sum could be stored in a single byte).
This is obviously completely unrealistic and will fit on any hard drive.</p>
<p>We hence use a customized version of a strategy called “sparse prefix sums” by Shekelyan et al. [1] to reduce the index size. We give a quick summary of the part of their method that is relevant to us:</p>
<p>They remove empty rows and columns from point matrices using lookup tables:</p>
<img src="../static/algorithmics_desc/sparse-matrices.png" /><p><em>Removing slices.</em></p>
<p>However, this strategy breaks down for large datasets.
To split too large datasets down into smaller ones they use overlays.</p>
<img src="../static/algorithmics_desc/sparse-matrices-in-large-datasets.png" /><p><em>Left: eventhough the matrix is sparse, there are no empty columns and rows. Right: by splitting the matrix into four submatrices, empty columns and rows can be removed again.</em></p>
<p>However, if we now compute the prefix sum for the individual submatrices we loose the ability to query arbitrary rectangles over our dataset.
To fix this, each overlay stores an additional first column and first row that holds the prefix sums of the entire dataset for those positions.
By then querying</p>
<ul class="simple">
<li><p>one position on the additional column,</p></li>
<li><p>one on the additional row,</p></li>
<li><p>one on the additional bottom-left corner</p></li>
<li><p>and one inside the overlay</p></li>
</ul>
<p>the prefix sum of arbitrary points can be queried again.</p>
<img src="../static/algorithmics_desc/querying-overlays.png" /><p><em>Querying overlays.</em></p>
<p>Combined with the querying technique in “F1: Constant lookup times” this gives us the ability to query arbitrary rectangles again.</p>
<p>So much for the technique of Shekelyan et al. [1].
With our dataset, we, however, ran into problems using this technique.
Overlays work best if points are evenly distributed among them.
Imagine a worst case, where all points are within the same overlay.
In that case we still pay the memory we would require for storing the points without overlays, but additionally have to store the remaining empty overlays.</p>
<p>Unfortunately, for our data we come close to this worst case.
Nucleic acid interactome data is heavily clustered along the 45-degree diagonal.
We found that there was no adequate overlay size tradeoff.
Either there would be too many empty overlays to store or the overlays on the diagonal would contain matrices that were too large to store.</p>
<p>Hence, we developed a strategy to distribute overlays better.
We break the grid-like organization of overlays and compute overlay height independently for each column.
We do this via the same lookup table strategy used for removing empty matrix columns and rows.
Here we use the lookup table in dimension 1 first.
Dimension 2 then has an individual lookuptable for each column of dimension 1. Here, the lookup of dimension 1 determines the used lookup table used for dimension 2.
This finally gives us a position in the materialized overlay grid.</p>
<img src="../static/algorithmics_desc/distributing-overlays.png" /><p><em>Overlay organization for nucleic acid interactome data.</em></p>
</section>
</section>
<section id="fileformat-specification">
<h3>Fileformat specification<a class="headerlink" href="#fileformat-specification" title="Permalink to this headline"></a></h3>
<p>Smoothers preprocessing creates several files.
In brief, these files contain the following information:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>file</p></th>
<th class="head"><p>desc</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>.desc</p></td>
<td><p>The description of all points.</p></td>
</tr>
<tr class="row-odd"><td><p>.points</p></td>
<td><p>The coordinates of all points.</p></td>
</tr>
<tr class="row-even"><td><p>.prefix_sums</p></td>
<td><p>The prefix sum for one position in space.</p></td>
</tr>
<tr class="row-odd"><td><p>.coords</p></td>
<td><p>The translation from real to sparse coordinates.</p></td>
</tr>
<tr class="row-even"><td><p>.overlays</p></td>
<td><p>The overlay grid.</p></td>
</tr>
<tr class="row-odd"><td><p>.datasets</p></td>
<td><p>The individual datasets.</p></td>
</tr>
<tr class="row-even"><td><p>meta</p></td>
<td><p>Some metadata about the index.</p></td>
</tr>
</tbody>
</table>
<p>Apart from the meta file, all files exist once for the interaction and once for the normalization data.</p>
<p>The exact content of these files is described <span class="raw-html-md"><a href="https://github.com/MarkusRainerSchmidt/libSps" title="Go to the libSps GitHub">here</a></span>.</p>
</section>
<section id="implementation-details">
<h3>Implementation Details<a class="headerlink" href="#implementation-details" title="Permalink to this headline"></a></h3>
<section id="libraries">
<h4>Libraries<a class="headerlink" href="#libraries" title="Permalink to this headline"></a></h4>
<p>Smoother is implemented in two separate parts:</p>
<ul class="simple">
<li><p>A Python 3 project that handles data visualization and normalization.</p></li>
<li><p>A C++ library that deals with the interaction counting and filesystem.</p></li>
</ul>
<p>The python project uses bokeh [5] to create an interactive viewer.
The C++ library uses pybind 11 [6] to create an interface for the python project and stxxl [7] for having access to a cached vector implementation.</p>
</section>
<section id="runtime-benchmarking">
<h4>Runtime benchmarking<a class="headerlink" href="#runtime-benchmarking" title="Permalink to this headline"></a></h4>
</section>
<section id="verification-of-normalizations">
<h4>Verification of Normalizations<a class="headerlink" href="#verification-of-normalizations" title="Permalink to this headline"></a></h4>
</section>
</section>
</section>
<section id="citing-smoother">
<h2>Citing Smoother<a class="headerlink" href="#citing-smoother" title="Permalink to this headline"></a></h2>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline"></a></h2>
<p>[1] Shekelyan, M., Dignös, A. &amp; Gamper, J. Sparse prefix sums: Constant-time range sum queries over sparse multidimensional data cubes. Information Systems 82, 136–147 (2019).</p>
<p>[2] Schmidt et al. &#64;todo</p>
<p>[3] Bonetti, A. et al. RADICL-seq identifies general and cell type–specific principles of genome-wide RNA-chromatin interactions. Nat Commun 11, 1018 (2020).</p>
<p>[4] Imakaev, M. et al. Iterative correction of Hi-C data reveals hallmarks of chromosome organization. Nat Methods 9, 999–1003 (2012).</p>
<p>[5] Bokeh…</p>
<p>[6] Pybind11</p>
<p>[7] stxxl</p>
</section>
<section id="thanks-to">
<h2>Thanks to…<a class="headerlink" href="#thanks-to" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Bokeh</p></li>
<li><p>Stxxl</p></li>
<li><p>Sparse Prefix Sums paper</p></li>
<li><p>Papers with the normalizations</p></li>
<li><p>Dataset origin</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Readme.html" class="btn btn-neutral float-left" title="Smoother" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Preprocess.html" class="btn btn-neutral float-right" title="Documentation for the Preprocessing script" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Markus Schmidt.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>